[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi, I’m Athena. I’m a journalism student at UT-Austin who likes data and Formula1.\nI’m making a website with Formula1 racing data for a class assignment in Intro Coding for Journalists. It is due Dec. 4, 2023.\nI’m using Visual Studio Code, Bootstrap and Nunjucks to make my website. But I like R and I’m using it to get the data from an API and get it ready for my website pages.\nHere’s the link to my website. As of the 2023 season, it is up to date!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Formula1 Data Analysis",
    "section": "",
    "text": "This is a Quarto website. To learn more about Quarto websites visit https://quarto.org/docs/websites.\nHi, my name is Athena Hawkins.\n\nI’m building a website with F1 stats using Formula1 data stored in the Ergast API. I created this notebook so I could easily update my website with driver and constructor standings after each round, or race, of the season.\nTo do this, I’ll pull the data from the API, convert into a format R can understand, and then upload it to a Google sheet, which will then update my website.\nThis notebook shows how I get the data from the API and organize the data for my website. Since I’ve never used an API before, I used AI to help me troubleshoot errors. If I used AI to help me with any code, I’ll explain what each line of code does.\nLet’s start by installing some libraries we need.\n\n\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(dplyr) #for getting API data\nlibrary(httr) #for converting API data into a format R can understand\nlibrary(jsonlite) #for converting API data into a format R can understand\nlibrary(googlesheets4) #for writing data to a Google sheet"
  },
  {
    "objectID": "index.html#about-this-notebook",
    "href": "index.html#about-this-notebook",
    "title": "Formula1 Data Analysis",
    "section": "",
    "text": "This is a Quarto website. To learn more about Quarto websites visit https://quarto.org/docs/websites.\nHi, my name is Athena Hawkins.\n\nI’m building a website with F1 stats using Formula1 data stored in the Ergast API. I created this notebook so I could easily update my website with driver and constructor standings after each round, or race, of the season.\nTo do this, I’ll pull the data from the API, convert into a format R can understand, and then upload it to a Google sheet, which will then update my website.\nThis notebook shows how I get the data from the API and organize the data for my website. Since I’ve never used an API before, I used AI to help me troubleshoot errors. If I used AI to help me with any code, I’ll explain what each line of code does.\nLet’s start by installing some libraries we need.\n\n\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(dplyr) #for getting API data\nlibrary(httr) #for converting API data into a format R can understand\nlibrary(jsonlite) #for converting API data into a format R can understand\nlibrary(googlesheets4) #for writing data to a Google sheet"
  },
  {
    "objectID": "index.html#create-functions-for-standings-data",
    "href": "index.html#create-functions-for-standings-data",
    "title": "Formula1 Data Analysis",
    "section": "Create functions for standings data",
    "text": "Create functions for standings data\nNow I’m going to create a function that will allow me to get updated driver standings (how many points a driver has so far) after any given race in a season. I’ll get updated data after each race so I can update the standings on my website.\nHere’s my function. It looks like a lot, but I’m going to break it down step by step below.\n\ngetDriverStandings &lt;- function(year, race) {\n  url &lt;- paste0(\"http://ergast.com/api/f1/\", year, \"/\", race, \"/driverStandings.json?limit=100\")\n  raw_dstandings &lt;- GET(url)\n  #get the raw content from the API for driverstandings\n  \n  dstandings_data &lt;- content(raw_dstandings, as = \"text\") |&gt; \n    fromJSON()\n  #convert raw content into data R can read\n\n  if (\n    !is.null(dstandings_data$MRData$StandingsTable$StandingsLists$DriverStandings[[1]])) \n  # condition for when the data does exist\n    \n    {\n    dstandings &lt;- dstandings_data$MRData$StandingsTable$StandingsLists$DriverStandings[[1]]\n  # extract the first response from the driver stanidngs list within all the standing tables\n\n    clean_driver_standings &lt;- dstandings |&gt; \n      mutate(\n        driverId = Driver$driverId,\n        constructorId = Constructors$constructorId\n      ) |&gt; \n      select(-positionText, -Driver, -Constructors) |&gt; \n      mutate(across(c(\"position\", \"points\", \"wins\"), as.integer))\n  # get the driverID from the Driver table and create acolumn for it and mutate numeric columns to read as integers\n\n    return(clean_driver_standings)\n  # the return for this condition\n  } \n  \n  else {\n    stop(\"Driver standings data not found or has unexpected structure.\")\n  }\n  # message to be returned if data can't be found, especially if the race hasn't happened or there is missing data in the API\n}\n\n\nThe standings function result\nAnd here’s the result of that function when we feed it a year and a round.\n\ncurrentdstandings &lt;- getDriverStandings(2023, 22)\n\ncurrentdstandings |&gt; head(10)\n\n   position points wins       driverId\n1         1    575   19 max_verstappen\n2         2    285    2          perez\n3         3    234    0       hamilton\n4         4    206    0         alonso\n5         5    206    0        leclerc\n6         6    205    0         norris\n7         7    200    1          sainz\n8         8    175    0        russell\n9         9     97    0        piastri\n10       10     74    0         stroll\n\n\n\n\nGetting the standings data from an API\nThe first few lines of code in our function set up the API call. Here’s what that means:\n\nWhen an API is queried (when we ask it for data), it responds with the data in a structured format, commonly JSON. The Ergast API we’re using offers data in several formats, but I wanted to work with JSON, so we added a .json to the url tibble.\nI wanted to create a function that would let me easily make new API calls based on the year and the race. I left spaces for the variables year and race in the url tibble.\nI wrote the rest of the call according to the Ergast documentation along with the GET function. Here it is.\nThen I used the fromJSON() function to put the content into a data frame in an R tibble.\n\nExtracting nested data - The API data often contains nested structures, where certain fields are lists or objects containing multiple elements. You can check out the structure of the Ergast API data here.\n\nIn R (or many programming languages), the $ operator is used to access components within a structure, like a list or a JSON object. That’s why we used the fromJSON() function, which I found in R documentation.\nI asked ChatGPT to help me write this line after I gave it specific information about the structure of the data and asked to extract the constructor standings. Here’s what it told me:\nThe line standings_data$MRData$StandingsTable$StandingsLists$ConstructorStandings is a chain of references to access nested components within standings_data which allows us to specify that we want the constructor standings table.\nOnce at a certain level of the nested structure, sometimes you might need to access specific elements within a list or object. That’s where the [[ ]] operator comes from. It’s used in R to extract elements from a list by specifying an index or a key.\n[[1]] is the key we used to access the first element of the list, constructor standings. In our case. this is the first response for “constructor standings” that comes back when we query the API.\n\n\n\nThe same function but for Constructors standings\nI used the same structure to create a formula for getting standings for the constructors (teams). Here’s what it looks like.\n\ngetConstructorStandings &lt;- function(year, race) {\nurl &lt;- paste0(\"http://ergast.com/api/f1/\", year,\"/\", race, \"/constructorStandings.json?limit=100\")\n  cstandings_raw &lt;- GET(url)\n\n  cstandings_data &lt;- content(cstandings_raw, as = \"text\") |&gt; \n    fromJSON()\n\n  if (!is.null(cstandings_data$MRData$StandingsTable$StandingsLists$ConstructorStandings[[1]])) {\n    cstandings &lt;- cstandings_data$MRData$StandingsTable$StandingsLists$ConstructorStandings[[1]]\n\n   cstandings_clean &lt;- cstandings |&gt; \n      mutate(\n        constructorId = Constructor$constructorId\n      ) %&gt;%\n      select(-Constructor, -positionText) |&gt; \n      mutate(across(c(\"position\", \"points\", \"wins\"), as.integer))\n\n    return(cstandings_clean)\n  } else {\n    stop(\"Constructor standings data not found or has unexpected structure.\")\n  }\n}\n\n\n\nConstructors standings results\nHere are the constructor standings we got. I hate that Ferrari is in second. But all looks correct!\n\ncurrentcstandings &lt;- getConstructorStandings(2023, 22)\n\ncurrentcstandings |&gt; head(5)\n\n  position points wins constructorId\n1        1    860   21      red_bull\n2        2    409    0      mercedes\n3        3    406    1       ferrari\n4        4    302    0       mclaren\n5        5    280    0  aston_martin"
  },
  {
    "objectID": "index.html#writing-results-to-google-sheets",
    "href": "index.html#writing-results-to-google-sheets",
    "title": "Formula1 Data Analysis",
    "section": "Writing results to Google Sheets",
    "text": "Writing results to Google Sheets\nWe installed the googlesheets4 package in our setup. It’s part of tidyverse and it’s really cool. You can read this documentation here to learn more about how to write data to an existing sheet.\n\nWrite drivers standings to google sheet\nI’m going to put the url for the Google sheet with my drivers data into a tibble, then use the range_write() funcion to import the current standings to the range I want!\n\n# Add Google sheet URL\ndriversheet_url &lt;- \"https://docs.google.com/spreadsheets/d/1ixos7uWmrzk0IJBtCcbNDnBh5UO6FDklzT7eTd1MXgE/edit#gid=0\"\n\n# Authenticate my Google account\ngs4_auth()\n\n! Using an auto-discovered, cached token.\n\n\n  To suppress this message, modify your code or options to clearly consent to\n  the use of a cached token.\n\n\n  See gargle's \"Non-interactive auth\" vignette for more details:\n\n\n  &lt;https://gargle.r-lib.org/articles/non-interactive-auth.html&gt;\n\n\nℹ The googlesheets4 package is using a cached token for\n  'athenahawkins@utexas.edu'.\n\n# Read the existing Google Sheet into R\nexisting_driversheet &lt;- gs4_get(driversheet_url)\n\nAuto-refreshing stale OAuth token.\n\n# Write the data frame to the Google Sheet\nexisting_driversheet |&gt;  \n  range_write(currentdstandings, range = \"A1:D23\")\n\n✔ Editing \"driverstats\".\n\n\n✔ Writing to sheet 'bios'.\n\n\nHere’s a link to the Google sheet. The first four rows of data come from this notebook!\n\n\nWrite constructor standings to Google sheets\nI’m going to do the same thing here for constructor standings.\n\n# Add Google sheet URL\nconstructorsheet_url &lt;- \"https://docs.google.com/spreadsheets/d/1NjnxaNQst0E1y6l-e4GTIqDsM2sRLll3ekCWpcG-lDo/edit?usp=sharing\"\n\n# Authenticate my Google account\ngs4_auth()\n\n! Using an auto-discovered, cached token.\n\n\n  To suppress this message, modify your code or options to clearly consent to\n  the use of a cached token.\n\n\n  See gargle's \"Non-interactive auth\" vignette for more details:\n\n\n  &lt;https://gargle.r-lib.org/articles/non-interactive-auth.html&gt;\n\n\nℹ The googlesheets4 package is using a cached token for\n  'athenahawkins@utexas.edu'.\n\n# Read the existing Google Sheet into R\nexisting_constructorsheet &lt;- gs4_get(constructorsheet_url)\n\n# Write the data frame to the Google Sheet\nexisting_constructorsheet |&gt;  \n  range_write(currentcstandings, range = \"A1:D11\")\n\n✔ Editing \"constructors\".\n\n\n✔ Writing to sheet 'teams'."
  },
  {
    "objectID": "index.html#get-circuits-data",
    "href": "index.html#get-circuits-data",
    "title": "Formula1 Data Analysis",
    "section": "Get circuits data",
    "text": "Get circuits data\nI’m going to download the circuits data because I’ll need to pull it each race anyways to get the most recent past winner.\n\ncircuits_raw &lt;- read_csv(\"data-raw/circuits.csv\")\nresults_raw &lt;- read_csv(\"data-raw/lap_times.csv\")\nraces_raw &lt;- read_csv(\"data-raw/races.csv\")\ndrivers_raw &lt;- read_csv(\"data-raw/drivers.csv\")\n\n\nGet circuit win data\nNow I want to get data for the past winners at each circuit, plus the circuit location. I’ll build these into my baked circuit pages.\n\nrace_winners &lt;- results_raw |&gt; \n  group_by(raceId) |&gt; \n  filter(lap == max(lap)) |&gt;  # Filter for the last lap\n  filter(position == 1) |&gt;    # Filter for position 1 in the last lap\n  ungroup()\n\n# Joining race_winners with results_raw based on raceId to get circuitId\nrace_winners_with_circuitId &lt;- race_winners |&gt; \n  left_join(races_raw |&gt;  select(raceId, circuitId, date), by = \"raceId\")\n\nrace_winners_with_circuitName &lt;- race_winners_with_circuitId |&gt;\n  left_join(circuits_raw |&gt; select(circuitId, name, location,country), by =\"circuitId\")\n\nrace_winners_per_circuit &lt;- race_winners_with_circuitName |&gt; \n  left_join(drivers_raw |&gt; select(driverId, surname, forename), by ='driverId')\n  \nrace_winners_circuit_name_years &lt;- race_winners_per_circuit |&gt; \n  mutate(yr = year(date),\n        winner_name = paste(forename, surname, sep = \" \"))\n\ncircuit_race_winners &lt;- race_winners_circuit_name_years |&gt; \n  filter(yr &gt;= 2016) |&gt; \n  select(name, winner_name, yr)\n\n\n\nCheck the result\nLet’s check to make sure we have the name of each race, the year it happened, and the winner.\n\ncircuit_race_winners |&gt; head(10)\n\n# A tibble: 10 × 3\n   name                           winner_name       yr\n   &lt;chr&gt;                          &lt;chr&gt;          &lt;dbl&gt;\n 1 Albert Park Grand Prix Circuit Nico Rosberg    2016\n 2 Bahrain International Circuit  Nico Rosberg    2016\n 3 Shanghai International Circuit Nico Rosberg    2016\n 4 Sochi Autodrom                 Nico Rosberg    2016\n 5 Circuit de Barcelona-Catalunya Max Verstappen  2016\n 6 Circuit de Monaco              Lewis Hamilton  2016\n 7 Circuit Gilles Villeneuve      Lewis Hamilton  2016\n 8 Baku City Circuit              Nico Rosberg    2016\n 9 Red Bull Ring                  Lewis Hamilton  2016\n10 Silverstone Circuit            Lewis Hamilton  2016\n\n\nI also want a tibble for just the most recent race winners for a card on the website.\n\nrecent_circuit_winners&lt;- circuit_race_winners |&gt; \n  filter(yr == 2023)\n\nrecent_circuit_winners |&gt; head(10)\n\n# A tibble: 10 × 3\n   name                           winner_name       yr\n   &lt;chr&gt;                          &lt;chr&gt;          &lt;dbl&gt;\n 1 Bahrain International Circuit  Max Verstappen  2023\n 2 Jeddah Corniche Circuit        Sergio Pérez    2023\n 3 Albert Park Grand Prix Circuit Max Verstappen  2023\n 4 Baku City Circuit              Sergio Pérez    2023\n 5 Miami International Autodrome  Max Verstappen  2023\n 6 Circuit de Monaco              Max Verstappen  2023\n 7 Circuit de Barcelona-Catalunya Max Verstappen  2023\n 8 Circuit Gilles Villeneuve      Max Verstappen  2023\n 9 Red Bull Ring                  Max Verstappen  2023\n10 Silverstone Circuit            Max Verstappen  2023\n\n\n\n\nWrite circuits to Google sheets\n\nrecent_circuit_winners\n\n# A tibble: 22 × 3\n   name                           winner_name       yr\n   &lt;chr&gt;                          &lt;chr&gt;          &lt;dbl&gt;\n 1 Bahrain International Circuit  Max Verstappen  2023\n 2 Jeddah Corniche Circuit        Sergio Pérez    2023\n 3 Albert Park Grand Prix Circuit Max Verstappen  2023\n 4 Baku City Circuit              Sergio Pérez    2023\n 5 Miami International Autodrome  Max Verstappen  2023\n 6 Circuit de Monaco              Max Verstappen  2023\n 7 Circuit de Barcelona-Catalunya Max Verstappen  2023\n 8 Circuit Gilles Villeneuve      Max Verstappen  2023\n 9 Red Bull Ring                  Max Verstappen  2023\n10 Silverstone Circuit            Max Verstappen  2023\n# ℹ 12 more rows\n\n\nI’m going to do the same thing I did with Google sheets for my drivers and constructors standings, but this time with circuits!\nLet’s start with just the recent winners.\n\n# Add Google sheet URL\nrecent_circuitsheet_url &lt;- \"https://docs.google.com/spreadsheets/d/1VOS_3RxH2i3Y7__A1VfdbmX_RPi7JmTa6WmIzfgne84/edit?usp=sharing\"\n\n# Read the existing Google Sheet into R\nrecent_existing_circuitsheet &lt;- gs4_get(recent_circuitsheet_url)\n\n# Write the data frame to the Google Sheet\nrecent_existing_circuitsheet |&gt;  \n  range_write(recent_circuit_winners, range = \"A1:C100\")\n\n✔ Editing \"circuits\".\n\n\n✔ Writing to sheet 'tracks'.\n\n\nAnd now for the all time stats.\n\n# Add Google sheet URL\nall_circuitsheet_url &lt;- \"https://docs.google.com/spreadsheets/d/1re902kjUgsT_eoqXD5Pk_KFj2uIumfIH_0qk9ax3S_g/edit?usp=sharing\"\n\n# Authenticate my Google account\ngs4_auth()\n\n! Using an auto-discovered, cached token.\n\n\n  To suppress this message, modify your code or options to clearly consent to\n  the use of a cached token.\n\n\n  See gargle's \"Non-interactive auth\" vignette for more details:\n\n\n  &lt;https://gargle.r-lib.org/articles/non-interactive-auth.html&gt;\n\n\nℹ The googlesheets4 package is using a cached token for\n  'athenahawkins@utexas.edu'.\n\n# Read the existing Google Sheet into R\nexisting_circuitsheet &lt;- gs4_get(all_circuitsheet_url)\n\n# Write the data frame to the Google Sheet\nexisting_circuitsheet |&gt;  \n  range_write(circuit_race_winners)\n\n✔ Editing \"all-time circuits\".\n\n\n✔ Writing to sheet 'tracks'."
  }
]